---
title: "7_novelty_etc"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(pacman)
p_load(tidyverse, entropy, multidplyr, parallel)
```


# DIVERGENCE FUNCTIONS FROM MALTE
```{r}
vdiff <- function(x,n,fun) sapply(n, function(i) fun(x,i))
vlag  <- function(x,n) vdiff(x,0:n,dplyr::lag)
vlead <- function(x,n) vdiff(x,0:n,dplyr::lead)

novelty2 <- function(w, cl, env) {
    # produce the lags (same shape as document)
    vlag(1:nrow(env$mat), w) %>%          
        parApply(cl = cl, X = ., MARGIN = 1,
                 function(idx, env) {
                     # then for each row (document)
                     #print(env)
                     mean(unlist(lapply(idx[2:length(idx)], function(i) {
                         #for each lag
                         #check if it's na (we're at beginning / end of data)
                         if (is.na(i)) return(NA)             
                         ## calculate surprise from past to present
                         KL.plugin(env$mat[i,], env$mat[idx[1],], unit = "log2")
                         
                     })))}, env = env)}


transience2 <- function(w, cl, env) {
    # produce the lags (same shape as document)
    vlag(1:nrow(env$mat), w) %>%          
        parApply(cl = cl, X = ., MARGIN = 1,
                 function(idx, env) {
                     # then for each row (document)
                     #print(env)
                     mean(unlist(lapply(idx[2:length(idx)], function(i) {
                         #for each lag
                         #check if it's na (we're at beginning / end of data)
                         if (is.na(i)) return(NA)             
                         ## calculate surprise from present to future
                         KL.plugin(env$mat[idx[1],], env$mat[i,], unit = "log2")
                         
                     })))}, env = env)}


z <- function(d) (d - mean(d)) / sd(d)
```

# new env and cluster
```{r}
cluster <- create_cluster(4) %>%
    cluster_library("entropy")
```

novelty-transience-resonance function
```{r}
calculate_ntr <- function(doc_subset_path, w) {
  
  dataenv = new.env()
  dataenv$mat = read_csv(doc_subset_path)
  
  ntr_output = tibble(doc_id = dataenv$mat$doc_id) %>%
    mutate(
      novelty = novelty2(w, cluster, dataenv),
      transience = transience2(w, cluster, dataenv),
      resonance = novelty - transience) %>%
    filter(complete.cases(.)) %>%
    mutate(z_novelty = z(novelty),
           z_transience = z(transience),
           z_resonance = z(resonance))
  
  res_nov_model = lm(z_resonance ~ z_novelty, data = ntr_output)
  ntr_output$delta_R = ntr_output$z_resonance - predict(res_nov_model)
  
  ntr_output %>%
    write_csv(paste0("data/ntr/", str_extract(doc_subset_path, "\\d"), "_from.csv"))
  
}


subset_paths <- list.files(path = "data/ntr/", pattern = "_to", full.names = T)[1]
calculate_ntr(subset_paths, w = 5000)

 
lapply(subset_paths, calculate_ntr, w = 5000)

```

